#############################################################
# 표준 입출력
#############################################################
cat notexist > /dev/null 2>&1
notexist 파일의 cat 명령 표준 출력 결과를 /dev/null 로 리다이렉션 시킨다.
실행한 결과와 에러 모두를 표시하지 않음

abcd > /dev/null 2>&1
명령 abcd 의 결과를 /dev/null 로 보내 흡수시킨다
즉 abcd 는 존재하지 않는 명령어기 때문에 발생한 에러를 출력하지 않음

#############################################################
# 쉘스크립트 자체변수
#############################################################
$$ : 쉘자체의 pid
$* : 모든 매개변수
$@ : 모든 매개변수 IFS에 영향을 받지 않음
$0 : 실행된 쉘파일 이름
$1~$2 : 위치파라메터
$? : 이전에 실행했던 명령어의 exit code
$? : 파라메터의 전체 갯수
#############################################################
# 퍼미션 변경 스크립트
#############################################################
function setperm {
  chown $1:$2 $1.*.keytab
  chmod 600 $1.*.keytab
}

#############################################################
# passwordless ssh를 이용하여 여러서버에 명령실행
# passwordless ssh를 이용하여 여러서버에 파일 복사
#############################################################
#!/bin/bash
while read line
  do
    ssh -n $line 'ls -al /tmp/'
done < servers.txt

#!/bin/bash
for hostnm in bdicr101x{07..16}h2
do 
scp $1 $hostnm:$2
done

#!/bin/bash
for hostnm in bdicr101x0{7..16}h2
  do
    ssh -n hostnm $1
done


#############################################################
#  로그파일 만들때 처음 시작부분
#  banner
#############################################################
function banner() {
    echo "*********************************"
    log_it "*** Starting: `basename ${BASH_SOURCE[0]}` Version: $VERSION ***"
    echo "*********************************"
}
#############################################################
#  쉘스크립트 시작시 파라메터 갯수 체크
#############################################################
if [ ${#} -lt 2 ]; then
  print_usage
  exit 1
fi

#############################################################
#  패키지가 이미 설치되어 있으면 종료 시키기
#############################################################
if rpm -qa | grep -q $package_name; then
    die "Package $package_name is already installed. Uninstall it first" 0
fi
export IS_MYSQL=`yum list -q installed MySQL-server > /dev/null 2> /dev/null; echo $?`
if [ $IS_MYSQL -eq 0 ] ; then
    log_it "INFO: Already installed MySQL Server.  Skipping."
    ## Start service just to be sure
    log_it `service mysql start`

    ## Enable mysql service at boot
    /sbin/chkconfig mysql on

     exit 0
fi
#############################################################
#  --- Exit function
# ${2:--1} => 2번째 파라메터가 없을때는 exit -1
#############################################################
function die() {
    log_it "ERROR: ${1}"
    exit ${2:--1};
}
#############################################################
#  --- log_it function
#############################################################
function log_it () {
    echo "$@"
	echo "[$(date +"%Y%m%d %H%M%S")]: $@" > $LOG_FILE
    #echo "[$(date +"%D %T")]: $@" >> $LOG_FILE
}


#############################################################
#  로그파일이 있는지 체크후 로그파일 만들기
#  -z 문자열 length is zero인지 비교시
#  -n 문자열 null 비교시
#############################################################
if [ -z $LOG_FILE ]; then
  mkdir -p $LOG_DIR
  LOG_FILE=$LOG_DIR/mysql_install-$NOW.log
fi

##############################################################
# awk를 이용해서 id 명령에서 uid와 id를 추출하기
##############################################################
echo `id|awk -F\( '{print $1}`
uid=79444917
echo `/usr/bin/id|awk -F\( '{print $1}'|awk -F= '{print $2}'`
79444917
echo `id|awk -F\( '{print $2}'|awk -F\) '{print $1}'`
gpainstall
##############################################################
# --- Must run as root
# 또는 whoami로 조회하는 방법과 id로 검색하는 방법이 있음
##############################################################
RUID=`/usr/bin/id|awk -F\( '{print $1}'|awk -F= '{print $2}'`
if [ $RUID -ne 0 ];then
    die  "You must be logged in as user with UID 0 (e.g. root user) to run $0 script." 1
fi
if [ `whoami` != "$INSTALL_ACCOUNT" ] ; then
  echo "ERROR: This script needs to be ran as $INSTALL_ACCOUNT user and it is being ran as: $(whoami)"
  exit 1
fi

##############################################################
# --- 파일의 존재여부를 체크하여 있으면 복사하기
&& 테스트 후 참이면 실행한다.
|| 테스트 후 거짓 이면 실행한다.
-d 디렉토리면 참
-f 파일이 존재하고 일반파일이면 참
-e 파일이 존재하면 참
-r 읽을수 있으면 참 -w 쓸수 있으면 참 -x 실행할 수 있으면 참
-s 파일이 존재하고 0바이트 보다 크면 참
-L 파일이 존재하고 링크파일이면 참
##############################################################
[ -d /tmp/test ] && mkdir /tmp/test2; cp -R /tmp/test/* /tmp/test2/
[ -f /tmp/cacerts ] && cp /tmp/cacerts /tmp/test/cacerts_test
[ -e /tmp/cacerts ] && cp /tmp/cacerts /tmp/test/cacerts_test2
[ -r /tmp/cacerts ] && cp /tmp/cacerts /tmp/test/cacerts_test3
[ -w /tmp/cacerts ] && cp /tmp/cacerts /tmp/test/cacerts_test4
[ -x /tmp/cacerts ] && cp /tmp/cacerts /tmp/test/cacerts_test5 || echo "now exists"
[ -s /tmp/cacerts ] && cp /tmp/cacerts /tmp/test/cacerts_test6
[ -L /tmp/ln_cacerts ] && cp /tmp/cacerts /tmp/test/cacerts_test7

##############################################################
# --- 명령어 실행하고 정상적으로 실행되었는지 확인하기
##############################################################
service mysql start
if [ $? -ne 0 ]; then
   log_it "Could not start MySQL service"
   exit 1
fi

##############################################################
# case 문에서 or 조건 사용하기
##############################################################
host_type=$1
case $host_type in 
        MASTER|PROXY|EDGE|CM|DB)
            echo "We have a valid host type: $host_type"
        ;;
        *)
           echo "Wrong server type provided. Must be in MASTER, CM , DB or PROXY"
           exit 1
        ;;
esac

##############################################################
# case 문에서 or 조건 사용하기
# or 조건 전체를 []로 감싸줘야 한다.
##############################################################
host_type=$1
if [[ $host_type == "PROXY" || $host_type == "MASTER" || $host_type == "CM" ]]; then
    echo $host_type
elif [[ $host_type == "DB" ]]; then
    echo $host_type
fi

#############################################################
# yum 명령어 옵션
#############################################################
yum install -y : 패키지를 설치한다. 의존성있는 패키지까지 설치한다.
                 -y 옵션을 줄 경우 묻지 않고 바로 설치한다.
yum update <패키지명>   : 패키지를 업데이트한다 패키지명이 없는경우
                          전체시스템에서 update될 패키지를 확인한고
						  업데이트를 한다.
yum downgrade   :   downgrade a package
yum search      :   Search package details for the given string	
yum provides '*/httpd.conf':httpd.conf를 포함하고 있는 모든 패키지를 출력한다.
yum repolist : 현재 활성화되 repolist를 출력한다.
yum clean    :  Remove cached data
yum localinstall : 다운로드 없이 로컬에있는 rpm을 가지고 설치하는경우
                   rpm으로 설치할 수도 있지만 yum으로 설치하면
				   설치기록이 남아서 rollback이 가능한다.
yum history list all
                 : yume 사용기록을 모두 볼수 잇다.
yum history info <트랜젝션id>
ex) yum history info 5
                 : 해당 트랜젝션 id에 대해 상세히 볼때 사용한다.
--downloadonly :don't update, just download
                위의 옵션을 사용하기 위해서는 yum-downloadonly패키지를 설치해야 한다.
ex) yum install yum-downloadonly
--downloaddir  :specifies an alternate directory to store packages
-v, --verbose  :       verbose operation
--disablerepo=* : 레파지토리가 여러개 있는경우 disable 시킨다.
--enablerepo="soe-bigdata-c5" 
  : soe-bigdata-c5 를 enable 시킨다.
  repo파일 명을 적는 게 아니라 repo파일 내부의 대괄호 안의 문자를
  기술해준다.
--nogpgcheck : GPG 서명검증을 사용하지 않는다.
               해당 repo의 공개키가 없어서 실패할 경우 사용한다.
#############################################################
# 설치가능한 rpm 목록 출력을 위한 yum 명령어
#############################################################
예제
for rpm in `yum list available --disablerepo=* --enablerepo="soe-bigdata-c5" | awk -F\. '{print $1}'`; do
  f=`echo $rpm | awk -F '.' '{print $1}'`
  echo $f
  echo "############# RPM $f locations ##############" >> rpm_log.txt
done

############################################################
# 현재 shell 스크립트가 실행되고 있는 경로 알아내기
############################################################
DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )

############################################################
# getopts 사용
# while getopts "ap:" option : 
# 파라메터가 있는 옵션을 처리할때는 콜론(:)을 사용한다.
# "$OPTARG"  
# 파라메터가 있는 옵션에서 파라메터를 받는 시스템 변수다.
# \?)
# case 문에서 지정되지 않은 옵션을 처리할때 사용한다.
# if [ -n $seperator ]; then
# 문자열 비교시 null이 아닌때
############################################################

#!/bin/bash
a_flag=0
seperator=""

while getopts "ap:" option
    do
       case $option in
       a)
         a_flag=1
        ;;
       p)
         seperator="$OPTARG"
        ;;
       \?)
         echo "invalid option"
         exit 1
       esac
    done

if [ $a_flag -eq 1 ]; then
  ls -al /tmp
else
  ls /tmp
fi

if [ -n $seperator ]; then
   echo $seperator
fi

########################################
# 사용자의 입력을 처리하는 방법
#########################################
# -p 프롬프트를 얻는다.
# response 사용자의 입력이 저장되는 변수
# response=${response,,}
# 소문자로 변환한다.
#response=${response^^}
# 대문자로 변환한다.
# if [[ $response =~ (yes|y| ) ]]; then
# 여러개의 문자를 비교하기 위한 방법
########################################
read -r -p "Are you sure? [Y/n] " response
response=${response,,} # to lower
if [[ $response =~ (yes|y| ) ]]; then
    echo "your response is yes"
elif [[ $response =~ (no|n| ) ]]; then
    echo "your response is no"
else
    echo "your response is $response"
fi

########################################
# how to use cp option
########################################
#원본파일 존재시 원본 복사본 만들고 복사.
cp -b /tmp/fetch.err /tmp/dir1
   마지막에 "~" 붙어서 생성됨
#원본파일 존재시 원본을 지우고 복사
cp -f /tmp/fetch.err /tmp/dir1
#원본디렉토리에 하위폴더 존재시 폴더까지 복사.
cp -R /tmp/dir1/ /tmp/dir2/
#원본파일 복사시에 퍼미션 오너 시간정보를 보존하여 복사.
#root로 실행할때만 가능함.
cp -p /tmp/dir1/ /tmp/dir2/


########################################
# how to check string empty & length
########################################
var=null
if[ -n "$var" ]; then
  echo "var=null is zero length"
fi

if[ ! -z "$var" ]; then
  echo "var=null is empty"
fi

var=""
if[ -n "$var" ]; then
  echo "var=\"\" is zero length"
else
  echo "var=\"\" is not zero length"
  echo "var=\"\" is not empty"
fi

var="abcd"
if[ ! -z "$var" ]; then
  echo "var\'s length is ${#var}"
fi

########################################
# how to use curl option
########################################
curl -k
  https에서 다운로드 받을때 지정하는 옵션으로 --insecure와 동일한다.
curl -O
  파일을 다운로드 할때 리모트 파일명과 동일하게 파일 다운로드 한다.
  동시에 여러 사이트에서 다운받을땐 아래처럼 한다.
  curl -O $URL -O $URL -O $URL ....
curl -u
  해당사이트에 user:passward를 지정할때 사용한다.
  curl -Ou admin:Cmpassdev1 -k https://XXXXXXXXXXXXXXXX:7183/api/v9/clusters/KRBDDEV/services
curl -o 
  다른이름으로 파일을 저장하려면 소문자 -o옵션을 사용한다. 
  curl -o service.json -k https://XXXXXXXXXXXXXXXX:7183/api/v9/clusters/KRBDDEV/services 
curl --cacert  
  인증서를 사용하여 다운로드
  curl -Ou admin:Cmpassdev1 --cacert /opt/Cloudera/ssl/ca-cert.pem https://XXXXXXXXXXXXXXXX:7183/api/v9/clusters/KRBDDEV/services
curl -#  
  Display transfer progress as a progress bar 
curl -T 
  curl을 이용한 파일 업로드 
  cloudera manager web root 디렉토리 /usr/share/cmf/webapp/
  기본적으로 세팅에서 업로드가 안되게 되어 있음.
  curl -u admin:Cmpassdev1 -T /tmp/fetch.err -kv https://XXXXXXXXXXXXXXXX:7183/
curl -X
  사용할 http 메소드를 기술한다.(POST or GET)  
  curl -XGET http://xxxxxxxxxxxxxxxx:19890/jobhistory
curl -L
  페이지가 없어졌을때 redirection URL에서 받아온다.  
  
########################################
# how to use echo option
########################################  
echo -n 
  줄바꿈 없이 출력한다. 아래명령어는 줄바꿈없이 한줄로 출력됨
  echo -n `ls -al /tmp`
echo -e
  문자열 해석 기능이 있어 ls, df 등의 명령어를 
  변수에 담아 출력할때 메일 본문에사용한다. 
########################################
# how to use find option
########################################  
#tmp directory 에서 type이 디렉토리고 datameer인 디렉토리를 찾는다.
find /tmp/ -type d -name "datameer"
#tmp directory 에서 type이 파일이고 CertAndKey.pfx 파일을 찾는다.
find /tmp  -type f -name CertAndKey.pfx
#tmp directory 에서 변경된지 5분 미만의 파일 찾기
find /tmp -mmin -5

#tmp directory 에서 변경된지 3일(72시간) 전 보다 새로운
find /tmp -mtime -3
#tmp directory 에서 변경된지 4일(96시간 전에서 3일(72시간)전까지(하루치)
find /tmp -mtime 3
#tmp directory 에서 변경된지 4일(96시간)보다 오래된
find /tmp -mtime +3
#tmp directory 에서 변경된지 4일 전부터 변경된지 2일전까지 
find /tmp -mtime -4 -mtime +1

######################################################################
# 1년이상 오래된 logfile 삭제 하기
# f옵션은 파일이 없을때 에러발생을 방지한다.
# v는 삭제한 파일명을 화면에 표시한다.
# -0 옵션을 사용하면 파일명에 공백이 있어도 에러발생을 방지한다.
# find 옵션도 구분자를 널문자로 출력하도록 하는 print0 옵션을 사용한다.
######################################################################
find /var/log/myapp/ -name "*.log" -mtime +364 -print0 | xargs -0 rm -fv

######################################################################
# log 파일을 찾아서 error이 있는 문자열만 출력
######################################################################

find ./ -name "*.log.*" -print | xargs grep "error" /dev/null

######################################################################
# 퍼미션을 이용한 파일의 검색
# -perm 644는 퍼미션이 정확히 644인 파일만 검색한다.
# -perm +001는 오너, 그룹, 아더중 1이상 일치하는 파일을 모두 찾는다.
# -perm +001는 other가 0이상인 파일을 찾는다.
# -perm -644는 오너, 그룹, 아더가 모두 지정된 퍼미션 이상인것을 찾는다.
######################################################################
find ./ -name "*.*" -perm 644
find ./ -name "*.*" -perm +001
find ./ -name "*.*" -perm -644

######################################################################
# 파일 소유권을 이용한 파일의 검색
# -user root 소유자가 root 파일을 검색
# -group root 소유그룹이 root 파일을 검색
######################################################################
find ./ -name "*.*" -user root
find ./ -name "*.*" -group root
 
######################################################################
# how to use awk option
1) Amit     Physics    80
2) Rahul    Maths      90
3) Shyam    Biology    87
4) Kedar    English    85
5) Hari     History    89
6) Demo1     User      58
7) test1    testdemo   78
######################################################################
파일을 읽어서 출력
awk '{print}' /etc/hosts
파일 시스템 use % 출력
  df -Ph | awk '{ print $5}'
선택한 컬럼만 추가
  df -Ph | awk '{ print $1, $3 }'
  awk '{print $3 " "  $4}' marks.txt
  awk '{print $3 "\t"  $4}' marks.txt
컬럼 간의 계산  
  df -P | awk  '{ print $1, $2 - $3}' | awk '{ print $1, $2/1024/1024}'
Row Number 표시 ($0: 전체 컬럼)
  df -Ph | awk '{ print NR, $0 }'
패턴 필터링 (주석 처리된 row만)
  awk '/^####/{print}' /etc/hosts
패턴 필터링 (x03h2로 시작하는줄)
  awk '/^19/{print}' /etc/hosts
패턴 필터링 (x03h2로 끝나는 줄)  
  awk '/x03h2$/{print}' /etc/hosts
패턴 필터링 (install 문자열앞에 g,p,a 가 있는 모든 줄 
  ls -l | awk '/[gpa]install/ {print}'
패턴 필터링 (파일이든 디렉토리든 퍼미션이 600인 것들)
  d- 문자로 시작하고 rw-------인 퍼미션인 파일들
  ls -l | awk '/[d-]rw-------/ {print}'
패턴 필터링 (와일드 카드)
  ls -l | awk '/bdicr101x0.h2/{print}'  
패턴 필터링 (숫자가 포함된 줄)  
  awk '/[0-9]/{print}' /etc/hosts  
패턴 필터링 (문자가 포함된 줄)  
  awk '/[a-Z]/{print}' /etc/hosts    
############################################################
# AWK를 이용한 파일 시스템 감시
# awk -v threshold 변수값 지정
# NR==1 {next} 현재의 row가 1인경우 skip
# $6=="/xenv1" {next} 번째 컬럼이 /xenv1인경우 skip
# $6=="/xenv2" {next} 번째 컬럼이 /xenv1인경우 skip
# {sub(/%/,"",$5)} $5에서 /%/를 찾아서 ""로 대체한다.
# printf 서식 지정자 출력
#  %s 문자열 그대로 출력 
#  %d%%\n" 5번열을 출력할때 %를 결합해서 출력하고 줄바꿈을 하라
############################################################
threshold=30
message=$(df -Ph | awk -v threshold="$threshold" '
   NR==1 {next}
   $6=="/xenv1" {next}
   $6=="/xenv2" {next}
   {sub(/%/,"",$5)}
   $5 > threshold {printf "%s is almost full: %d%%\n", $6, $5}')
echo $message  
  
  
########################################
# how to use sed option
below text is test.txt
one two three, one two three
four three two one
one hundred
and you used the command
########################################
1 단순 찾아 바꾸기
   sed 's/ovr-usr/ovr-user/' df.txt > df-Ph.txt
   아래 명령어는 위와 동일 하다.
   sed 's/ovr-usr/ovr-user/' <df.txt > df-Ph.txt
   
2. 파일에서 찾아 바꾸기
   g(global) 옵션이 없으면 한줄에서 첫번째 패턴 매치되는 단어만 replace된다.
   sed 's/one/ONE/' < test.txt   
   g(global) 옵션이 있으면 전체파일에서 패턴 매치되는 모든 단어만 replace된다.
   sed 's/one/ONE/g' < test.txt   
   output :
   ONE two three, one two three
   four three two ONE
   ONE hundred
   and you used the command
3 escape 문자의 처리   
   echo "/usr/local/bin" | sed 's/\/usr\/local\/bin/\/common\/bin/' 
   output :
   /common/bin/
   
4. escape 문자의 처리없이 특수문자 처리
   (|, _ 도 동일한 기능을 한다.)
   echo "/usr/local/bin/" | sed 's:/usr/local/bin/:/common/bin/:' 
   output :
   /common/bin/
   
5. 첫번째 줄 다음에 append 
   sed '1a many number' test.txt
   output :
   one two three, one two three
   many number
   four three two one
   one hundred
   and you used the command

6. 첫번째 줄에 insert
   sed '1i many number' test.txt
   output :
   many number
   one two three, one two three
   four three two one
   one hundred
   and you used the command
   
7. 행이 포함된 라인 번호 찾기
   sed -n '/hundred/=' test.txt
   output :
   3
   
8. 전체 라인 수를 리턴한다.
   sed -n '$=' test.txt
   output :
   4
   
9. 마지막 line을 replace 한다.
   sed '$c last line of the file' test.txt 
   output :
   one two three, one two three
   four three two one
   one hundred
   last line of the file
   
10. 첫번째 line을 replace 한다.   
   sed '1c first line of the file' test.txt 
   
11. 패턴 검색하여 찾은열 다음열에 문자열을 삽입한다.
   sed '/four/a fourth' test.txt   
   output :
   one two three, one two three
   four three two one
   fourth
   one hundred
   and you used the command
   
12. 패턴 검색하여 찾은열 전열에 문자열을 삽입한다.
   sed '/four/i fourth' test.txt   
   output :
   one two three, one two three
   four three two one
   fourth
   one hundred
   and you used the command   

########################################
# 숫자 비교
# gt lt le ge eq ne(not equal)
########################################   
num1=$1
num2=$2
num3=$3

echo "param1 $num1"
echo "param2 $num2"
echo "param3 $num3"

if [ $num1 -eq $num2 ]; then
  echo "param1 and parma2 same"
elif [ $num1 -gt $num2 ]; then
  echo "param1 is greater than parma2"
elif [ $num1 -lt $num2 ]; then
  echo "param1 lt less than parma2"
fi

if [ $num1 -ge $num2 ]; then
  echo "param1 is greater or same than parma2"
fi

if [ $num1 -le $num2 ]; then
  echo "param1 is less or same than parma2"
fi

###################
#and or expression
###################
if [ $num1 -gt $num2 ] && [ $num1 -gt $num3 ]; then
  echo "param1 is gretest of all"
fi

if [ $num1 -gt $num2 ] || [ $num1 -gt $num3 ]; then
  echo "param1 is grater than param2 or param3"
fi

##########################
# 숫자 기호를 사용한 표현
#use ((
##########################

if  (( "$num1" == "$num2" )); then
  echo "use ((  :  param1 and parma2 are same"
elif (( "$num1" > "$num2" )); then
  echo "use ((  : param1 is greater than parma2"
elif (( "$num1" < "$num2" )); then
  echo "use ((  : param1 lt lower than parma2"
fi

##########################
# 숫자 연산 표현
#use ((
##########################

for i in {1..100}
do
  # 산술 확장을 이용해서 파일명에 3을 곱해서 계산한
  # 값을 텍스트 파일에 저장
  #(2)
  echo $((i * 3)) > ${i}.txt
done
########################################
# 조건에 만족하는 숫자 출력
########################################
a=3
b=2
echo $(( a < b ? a : b ))

########################################
# 문자 비교, 문자 테스트
######################################## 

char1="$1"
char2="$2"

echo "param1 $char1"
echo "param2 $char2"

if [ $char1 == $char2 ]; then
  echo "== : param1 and param2 are same"
elif [ $char1 != $char2 ]; then
  echo "!= : param1 is not equal parma2"
fi

if [ ! -z "$char1" ]; then
  echo "! -z : param1 length is not zero"
else
  echo "! -z : param1 length is zero"
fi  
if [ -n "$char1" ]; then
  echo "!= : param1 is not null"
else 
  echo "!= : param1 is null" 
fi

########################################
# 문자 연결
######################################## 

today=`date  +%Y%m%d`
echo ${today}_log.log

############################################################################
# 배열의 선언과 추출
# { 를 붙이면 one을 추출하지만
# { 를 붙이지 않으면 첫번재 요소 zero에 [1]를 연결한 문자를 리턴 한다.
# 아래 코드 실행 안됨.
############################################################################

declare -a number=("zero","one","two")
echo ${number[1]}

############################################################################
# 로그파일에서 "PluginManifestParser" 문자열 갯수 출력
# grep -c 
############################################################################
logfile="/var/app/datameer/current/logs/conductor.log"
filter_count=$(grep -c "PluginManifestParser" $logfile)
echo "ERROR count : $filter_count"

############################################################################
# 파일에서 줄 수 출력
# wc <파일명>
# 옵션 -c(bytes) -m(char) -l(line) -w(word)
# output 줄수 단어수 라인수 파일명을 리턴한다.
# 6 20 87 test.txt
############################################################################
logfile="/var/app/datameer/current/logs/conductor.log.1"
char_count=$(wc  $logfile)
echo "char count : $char_count"

############################################################################
# 날짜 관련 조작
############################################################################
#내일
date -d '1day' +%Y%m%d
#어제 
date -d '1day ago' +%Y%m%d
#2틀전
date -d '2day ago' +%Y%m%d
#다음달
date -d '1month' +%Y%m%d
#한달 전
date -d '1month ago' +%Y%m%d
#년도만 얻기
date +%Y
#월만 얻기
date +%m
#일만 얻기
date +%d
############################################################################
# 날짜관련 비교(epoch)
############################################################################
day1="20140102 10:10:10"
day2="20140101 10:10:10"
#epoch 초 얻기
#하루는 1440분 86400초
epoch_day1=$(date -d "$day1" '+%s')
epoch_day2=$(date -d "$day2" '+%s')
interval=`expr \( $epoch_day1 - $epoch_day2 \) / 86400`
echo $interval
## mysql unix time에서 시간 구하기 함수
select FROM_UNIXTIME(1333063912)

############################################################################
# 로그파일 작성시 날짜의 입력
############################################################################
LOG_FILE=LOG.txt
function log_it () {
    echo "$@"
    echo "[$(date +"%Y/%m/%d %T")]: $@" >> $LOG_FILE
}

log_it "This is Test!"


########################################
# 디렉토리의 파일리스트 표시
######################################## 
#!/bin/bash
for logfile in /tmp/*.log.*
do
  echo $logfile
done

###################################################### 
# basename 디렉토리의 경로를 제거한 파일리스트 표시
# basename에 2번째 파라메터로 확장자를 
# 입력하면 확장자가 제거된 파일리스트를 얻을수 있다.
###################################################### 
#!/bin/bash
for logfile in /tmp/*.err
do
  logname=$(basename $logfile .err)
  echo $logname
done


###################################################### 
# dos2unix
###################################################### 
function dos2unix () {
sed -i 's/\r//g' *.sh
sed -i 's/^M$//g' *.sh
}

############################################################################ 
# 환경설정 파일에서 속성에 매핑된 value 추출하기
# 환경설정 파일에는 cdh.parcel.version=5.7.0이라고 입력되어있음
# `cat config.ini|grep ^cdh.parcel.version|awk -F\= '{print $2}'`
# config.ini에서 grep으로 ^cdh.parcel.version로 시작하는 열을 검색하고
# 검색된 결과를 awk를 이용하여 = 구분자로 구분한후 2번째 컬럼을 출력
############################################################################
 
CDH_PARCEL_VERSION=`cat config.ini|grep ^cdh.parcel.version|awk -F\= '{print $2}'`
grep_version=`cat config.ini|grep cdh.parcel.version`
echo "grep_version" $grep_version
echo "CDH_PARCEL_VERSION" $CDH_PARCEL_VERSION

############################################################################ 
# 메일 발송하기
#mailer_util.sh 
# SYNTAX: bash mailer_util.sh <FROM> <TO> <SUBJECT> <ATTACHMENT>
# EXAMPLE: bash mailer_util.sh "$FROM" "$TO" "$SUBJECT" "$CSVFILE"
############################################################################ 
FROM=$1
TO=$2
SUBJECT=$3
boundary="ZZ_/afg6432dfgkl.94531q"
body=`cat "$4"`

declare -a attachments
attachments=( $5 )

get_mimetype(){
  # warning: assumes that the passed file exists
  file --mime-type "$1" | sed 's/.*: //' 
}



# Build headers
{

printf '%s\n' "From: $FROM
To: $TO
Subject: $SUBJECT
Mime-Version: 1.0
Content-Type: multipart/mixed; boundary=\"$boundary\"

--${boundary}
Content-Type: text/plain; charset=\"US-ASCII\"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

$body
"
 
# now loop over the attachments, guess the type
# and produce the corresponding part, encoded base64
for file in "${attachments[@]}"; do

  [ ! -f "$file" ] && echo "Warning: attachment $file not found, skipping" >&2 && continue

  mimetype=$(get_mimetype "$file") 
 
  printf '%s\n' "--${boundary}
Content-Type: $mimetype
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename=\"$file\"
"
 
  base64 "$file"
  echo
done
 
# print last boundary with closing --
printf '%s\n' "--${boundary}--"
 
} | sendmail -t -oi   



